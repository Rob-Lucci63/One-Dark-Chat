<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>One Ai - Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ</title>
  <style>
    body { font-family: Tahoma, sans-serif; direction: rtl; background: #f4f4f4; margin: 0; padding: 0; }
    #chatContainer { max-width: 650px; margin: 20px auto; background: #fff; border-radius: 10px; padding: 20px; box-shadow: 0 0 15px #ccc; }
    h1 { text-align: center; color: #0074d9; margin-top: 0; }
    #messages { height: 450px; overflow-y: auto; padding: 10px; border: 1px solid #ccc; background: #fafafa; margin-bottom: 10px; }
    .message { margin: 6px 0; padding: 10px 14px; border-radius: 12px; max-width: 75%; clear: both; line-height: 1.6; word-wrap: break-word; }
    .user { background: #d0e6ff; float: left; }
    .bot { background: #eeeeee; float: right; }
    input[type=text] { width: calc(100% - 24px); padding: 10px; font-size: 15px; border-radius: 8px; border: 1px solid #ccc; }
    button { margin-top: 10px; width: 100%; padding: 10px; background: #0074d9; color: white; font-size: 15px; border: none; border-radius: 8px; cursor: pointer; }
    button:hover { background: #005fa3; }
    #footer { text-align: center; margin-top: 20px; color: gray; font-size: 14px; }
  </style>
</head>
<body>
<div id="chatContainer">
  <h1>ğŸ¤– One Ai (V0.0.6)</h1>
  <div id="messages"></div>
  <input type="text" id="userInput" placeholder="Ù‡Ø±Ú†ÛŒ Ø¯ÙˆØ³Øª Ø¯Ø§Ø±ÛŒ Ø¨Ù†ÙˆÛŒØ³..." onkeydown="if(event.key==='Enter') sendMessage();" />
  <button onclick="sendMessage()">Ø§Ø±Ø³Ø§Ù„</button>
  <div id="footer">Ø³Ø§Ø®ØªÙ‡ Ø´Ø¯Ù‡ ØªÙˆØ³Ø· Rob Lucci</div>
</div>
<script>
  const messages = document.getElementById('messages');
  const userInput = document.getElementById('userInput');
  let lastBotQuestion = null;

  const fallbackReplies = [
    "Ù…ØªÙˆØ¬Ù‡ Ù†Ø´Ø¯Ù… Ú©Ø§Ù…Ù„ØŒ ÙˆÙ„ÛŒ Ø­Ø±ÙØªÙˆ Ø¯ÙˆØ³Øª Ø¯Ø§Ø´ØªÙ… ğŸ˜…",
    "Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ ÛŒÙ‡ Ø°Ø±Ù‡ ÙˆØ§Ø¶Ø­â€ŒØªØ± Ø¨Ú¯ÛŒØŸ ğŸ‘€",
    "Ø´Ø§ÛŒØ¯ Ø³ÙˆØ§Ù„ Ø³Ø®ØªÛŒ Ø¨ÙˆØ¯ ÙˆÙ„ÛŒ Ø¬Ø§Ù„Ø¨Ù‡!",
    "Ø¯Ø§Ø±Ù… Ø³Ø¹ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ù… Ø¨ÙÙ‡Ù…Ù…ØŒ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¨Ú¯Ùˆ Ù„Ø·ÙØ§Ù‹ âœ¨"
  ];

  const yesWords = ['Ø¢Ø±Ù‡','Ø¨Ù„Ù‡','yes','Ø­ØªÙ…Ø§','Ø§ÙˆÚ©ÛŒ','Ø¨Ø§Ø´Ù‡'];
  const noWords = ['Ù†Ù‡','Ø®ÛŒØ±','Ù†Ù‡ Ø¨Ø§Ø¨Ø§','Ø§ØµÙ„Ø§Ù‹','no'];

  const dictionary = [
    { keywords: ['Ø³Ù„Ø§Ù…','Ø¯Ø±ÙˆØ¯','ØµØ¨Ø­ Ø¨Ø®ÛŒØ±','Ø¹ØµØ± Ø¨Ø®ÛŒØ±'], answer: 'Ø³Ù„Ø§Ù… Ø±ÙÛŒÙ‚! Ø­Ø§Ù„Øª Ú†Ø·ÙˆØ±Ù‡ØŸ ğŸŒ' },
    { keywords: ['Ø®ÙˆØ¨ÛŒ','Ú†Ø·ÙˆØ±ÛŒ','Ø­Ø§Ù„Øª','Ø§Ø­ÙˆØ§Ù„'], answer: 'Ù…Ù† Ø¹Ø§Ù„ÛŒâ€ŒØ§Ù…! ØªÙˆ Ú†Ø·ÙˆØ±ÛŒØŸ ğŸ˜„' },
    { keywords: ['Ø±Ø¨Ø§Øª','ØªÙˆ Ú©ÛŒ Ù‡Ø³ØªÛŒ','Ø§Ø³Ù…','one ai'], answer: 'Ù…Ù† One Ai Ù‡Ø³ØªÙ…ØŒ Ø±ÙÛŒÙ‚ Ø¯ÛŒØ¬ÛŒØªØ§Ù„ÛŒ ØªÙˆ ğŸ¤–' },
    { keywords: ['Ø¹Ø´Ù‚','Ø¯ÙˆØ³Øª Ø¯Ø§Ø´ØªÙ†','Ø¹Ø§Ø´Ù‚','Ø§Ø­Ø³Ø§Ø³'], answer: 'Ø¹Ø´Ù‚ Ú†ÛŒØ²ÛŒÙ‡ Ú©Ù‡ Ù‡Ù… Ù‚Ø´Ù†Ú¯Ù‡ØŒ Ù‡Ù… Ø¯Ø±Ø¯ Ø¯Ø§Ø±Ù‡... ØªÙˆ Ú†ÛŒ ÙÚ©Ø± Ù…ÛŒâ€ŒÚ©Ù†ÛŒØŸ â¤ï¸' },
    { keywords: ['ØºÙ…','Ø§ÙØ³Ø±Ø¯Ù‡','Ù†Ø§Ø±Ø§Ø­ØªÙ…','Ø­Ø§Ù„Ù… Ø¨Ø¯Ù‡'], answer: 'Ø¨ÛŒØ§ ÛŒÙ‡ Ø¯Ù„ Ø³ÛŒØ± Ø­Ø±Ù Ø¨Ø²Ù†ÛŒÙ… ØªØ§ Ø­Ø§Ù„Øª Ø¨Ù‡ØªØ± Ø´Ù‡ ğŸ˜”' },
    { keywords: ['Ø¨Ø§Ø²ÛŒ','Ú¯ÛŒÙ…','Ø³Ø±Ú¯Ø±Ù…ÛŒ'], answer: 'Ø¨Ø§Ø²ÛŒ Ø®ÙˆØ¨ Ø³Ø±Ø§Øº Ø¯Ø§Ø±ÛŒØŸ Ù…Ù† Ú©Ù‡ Happy Coin Ø±Ùˆ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù…ÛŒâ€ŒÚ©Ù†Ù… ğŸ®' },
    { keywords: ['ÙÛŒÙ„Ù…','Ø³Ø±ÛŒØ§Ù„','Ø§Ù†ÛŒÙ…Ù‡'], answer: 'Ú˜Ø§Ù†Ø± Ù…ÙˆØ±Ø¯ Ø¹Ù„Ø§Ù‚Øª Ú†ÛŒÙ‡ØŸ Ù…Ù† Ú©Ù‡ Ø¹Ø§Ø´Ù‚ ÙˆØ§Ù† Ù¾ÛŒØ³Ù…! ğŸ¬' },
    { keywords: ['Ú©ØªØ§Ø¨','Ù…Ø·Ø§Ù„Ø¹Ù‡','Ú©ØªØ§Ø¨Ø®ÙˆÙ†ÛŒ'], answer: 'Ú©ØªØ§Ø¨ Ø®ÙˆÙ†Ø¯ÛŒØŸ Ù…ÙˆØ¶ÙˆØ¹Ø´ Ú†ÛŒ Ø¨ÙˆØ¯ØŸ ğŸ“š' },
    { keywords: ['Ø¨Ø±Ù†Ø§Ù…Ù‡ Ù†ÙˆÛŒØ³ÛŒ','Ú©Ø¯','Ú©Ø¯Ù†ÙˆÛŒØ³ÛŒ'], answer: 'Ú©Ø¯Ù†ÙˆÛŒØ³ÛŒ ÛŒÙ‡ Ø¯Ù†ÛŒØ§ÛŒ Ø¨ÛŒâ€ŒÙ†Ù‡Ø§ÛŒØªÙ‡! Ø¨Ø²Ù† Ø¨Ø±ÛŒÙ… Ø¨Ø³Ø§Ø²ÛŒÙ… ğŸ˜' },
    { keywords: ['Ø¯ÛŒØ³Ú©ÙˆØ±Ø¯','Ú†Øª','Ù¾ÛŒØ§Ù…','Ø³Ø±ÙˆØ±'], answer: 'Ø¯ÛŒØ³Ú©ÙˆØ±Ø¯ Ø®ÛŒÙ„ÛŒ Ø¨Ø§Ø­Ø§Ù„Ù‡! ØªÙˆ Ú†Ù‡ Ø³Ø±ÙˆØ±Ø§ÛŒÛŒ ÙØ¹Ø§Ù„ÛŒØŸ ğŸ’¬' },
    { keywords: ['ØªÛŒÚ© ØªØ§Ú©','Ø§ÛŒÙ†Ø³ØªØ§','Ø´Ø¨Ú©Ù‡ Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ'], answer: 'Ú†Ù‡ Ù…Ø­ØªÙˆØ§ÛŒÛŒ Ù…ÛŒâ€ŒØ³Ø§Ø²ÛŒ ÛŒØ§ Ø¯Ù†Ø¨Ø§Ù„ Ù…ÛŒâ€ŒÚ©Ù†ÛŒØŸ ğŸ“±' },
    { keywords: ['Ù¾ÙˆÙ„','Ø¯Ø±Ø¢Ù…Ø¯','Ø´ØºÙ„','Ú©Ø§Ø±'], answer: 'Ø±Ø§Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø±Ø¢Ù…Ø¯ Ø²ÛŒØ§Ø¯ÛŒ Ù‡Ø³ØªØŒ ØªÙˆ Ú†ÛŒ Ù…Ø¯ Ù†Ø¸Ø±ØªÙ‡ØŸ ğŸ’¼' },
    { keywords: ['Ø¯Ø±Ø³','Ù…Ø¯Ø±Ø³Ù‡','Ø§Ù…ØªØ­Ø§Ù†','ØªØ­ØµÛŒÙ„'], answer: 'Ø¯Ø±Ø³Ø§Øª Ú†Ø·ÙˆØ± Ù¾ÛŒØ´ Ù…ÛŒØ±Ù‡ØŸ Ú©Ù…Ú© Ø®ÙˆØ§Ø³ØªÛŒ Ù…Ù† Ù‡Ø³ØªÙ… ğŸ“˜' },
    { keywords: ['Ù‡Ø¯Ù','Ø¨Ø±Ù†Ø§Ù…Ù‡','Ø¢ÛŒÙ†Ø¯Ù‡','Ø±ÙˆÛŒØ§'], answer: 'Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØª Ø¨Ø±Ø§ÛŒ Ø¢ÛŒÙ†Ø¯Ù‡ Ú†ÛŒÙ‡ØŸ' },
    { keywords: ['ÙˆØ±Ø²Ø´','ØªÙ…Ø±ÛŒÙ†','Ø³Ù„Ø§Ù…ØªÛŒ','Ø¨Ø¯Ù†'], answer: 'Ø³Ù„Ø§Ù…ØªÛŒØª Ù…Ù‡Ù…Ù‡! Ú†Ù‡ ÙˆØ±Ø²Ø´ÛŒ Ù…ÛŒâ€ŒÚ©Ù†ÛŒØŸ ğŸ’ª' },
    { keywords: ['Ø®Ø³ØªÙ‡','Ø®ÙˆØ§Ø¨','Ø§Ø³ØªØ±Ø§Ø­Øª'], answer: 'ÛŒÙ‡ Ú†Ø±Øª Ú©ÙˆÚ†ÙˆÙ„Ùˆ Ø¨Ø²Ù†ØŒ Ø±ÛŒÚ©Ø§ÙˆØ±ÛŒ Ù…ÛŒØ´ÛŒ ğŸ˜´' },
    { keywords: ['Ø¬ÙˆÚ©','Ø®Ù†Ø¯Ù‡','Ø¨Ø®Ù†Ø¯ÙˆÙ†Ù…'], answer: 'Ø¬ÙˆÚ©: Ú†Ø±Ø§ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒÙ†ÙˆÛŒØ³Ø§ Ú¯Ø±Ø¨Ù‡ Ù†Ú¯Ù‡ Ù†Ù…ÛŒâ€ŒØ¯Ø§Ø±Ù†ØŸ Ú†ÙˆÙ† mouse Ø¯Ø§Ø±Ù†! ğŸ˜‚' },
    { keywords: ['Ø®Ø¯Ø§Ø­Ø§ÙØ¸','Ø¨Ø§ÛŒ','ÙØ¹Ù„Ø§'], answer: 'ÙØ¹Ù„Ø§Ù‹ Ø±ÙÛŒÙ‚ØŒ Ù…Ù†ØªØ¸Ø±Ù… Ø¨Ø±Ú¯Ø±Ø¯ÛŒ! ğŸ–ï¸' },
    { keywords: ['Ø³ÙØ±','Ú¯Ø±Ø¯Ø´','Ø·Ø¨ÛŒØ¹Øª','Ù…Ø³Ø§ÙØ±Øª'], answer: 'Ú©Ø¬Ø§ Ø¯ÙˆØ³Øª Ø¯Ø§Ø±ÛŒ Ø³ÙØ± Ø¨Ø±ÛŒØŸ ğŸŒ' },
    { keywords: ['ØºØ°Ø§','Ø±Ø³ØªÙˆØ±Ø§Ù†','Ø®ÙˆØ±Ø§Ú©ÛŒ','Ø¢Ø´Ù¾Ø²ÛŒ'], answer: 'ØºØ°Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ø¹Ù„Ø§Ù‚Øª Ú†ÛŒÙ‡ØŸ Ù…Ù† Ú©Ù‡ Ù¾ÛŒØªØ²Ø§ ğŸ˜‹' },
    { keywords: ['Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ','AI','Ø±Ø¨Ø§Øª','Ù…Ø§Ø´ÛŒÙ†'], answer: 'Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¢ÛŒÙ†Ø¯Ù‡ Ø±Ùˆ Ù…ÛŒâ€ŒØ³Ø§Ø²Ù‡ØŒ Ù…ÛŒâ€ŒØ®ÙˆØ§ÛŒ Ø¨Ø§Ù‡Ø§Ø´ Ø¨Ø³Ø§Ø²ÛŒØŸ ğŸ¤–' }
  ];

  function levenshtein(a, b) {
    const matrix = [];
    for (let i = 0; i <= b.length; i++) matrix[i] = [i];
    for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        matrix[i][j] = Math.min(
          matrix[i - 1][j] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j - 1] + (b[i - 1] === a[j - 1] ? 0 : 1)
        );
      }
    }
    return matrix[b.length][a.length];
  }

  function findBestMatch(text) {
    let bestItem = null, bestScore = Infinity;
    const words = text.split(/\s+/);
    for (let item of dictionary) {
      for (let kw of item.keywords) {
        for (let w of words) {
          const dist = levenshtein(w.toLowerCase(), kw.toLowerCase());
          if (dist < bestScore) {
            bestScore = dist;
            bestItem = item;
          }
        }
      }
    }
    return bestScore <= 2 ? bestItem : null;
  }

  function extractQuestions(text) {
    const sentences = text.split(/[.ØŸ!?]/).map(s => s.trim()).filter(Boolean);
    const qWords = ['Ú†ÛŒ','Ú†Ø±Ø§','Ú†Ø·ÙˆØ±','Ú©Ø¬Ø§','Ú†Ù‡','Ú†Ù†Ø¯','Ø¢ÛŒØ§','Ú©ÛŒ','Ú†Ú¯ÙˆÙ†Ù‡'];
    return sentences.filter(s => qWords.some(w => s.startsWith(w) || s.includes(' ' + w)));
  }

  function isAnswerToLastQuestion(text) {
    const isQuestion = /[ØŸ?]/.test(text);
    const hasVerb = /(Ú©Ø±Ø¯Ù…|Ø¯ÛŒØ¯Ù…|Ø®Ø±ÛŒØ¯Ù…|Ø±ÙØªÙ…|Ø®ÙˆÙ†Ø¯Ù…|ÛŒØ§Ø¯Ù…Ù‡|Ø¢ÙˆØ±Ø¯Ù…|Ø¯Ø§Ø±Ù…|Ø²Ø¯Ù…|Ù…ÛŒâ€ŒØ®ÙˆØ§Ù…|Ø³Ø§Ø²Ù…|Ù…ÛŒâ€ŒØ³Ø§Ø²Ù…)/i.test(text);
    return lastBotQuestion && !isQuestion && hasVerb;
  }

  function handleYesNo(text) {
    const lower = text.toLowerCase();
    if (lastBotQuestion) {
      if (yesWords.includes(lower)) return 'Ø¹Ø§Ù„ÛŒÙ‡! Ø¨Ø±ÛŒÙ… Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯ÛŒÙ… ğŸ˜Š';
      if (noWords.includes(lower)) return 'Ø¨Ø§Ø´Ù‡ØŒ Ù…ÙˆØ¶ÙˆØ¹ Ø±Ùˆ Ø¹ÙˆØ¶ Ú©Ù†ÛŒÙ…ØŸ';
    }
    return null;
  }

  function addMessage(text, sender) {
    const msg = document.createElement('div');
    msg.classList.add('message', sender);
    msg.textContent = text;
    messages.appendChild(msg);
    messages.scrollTop = messages.scrollHeight;
  }

  function sendMessage() {
    const text = userInput.value.trim();
    if (!text) return;
    addMessage(text, 'user');
    userInput.value = '';

    setTimeout(() => {
      let response = null;

      if (isAnswerToLastQuestion(text)) {
        response = 'Ø§ÙˆÙ‡ ÙÙ‡Ù…ÛŒØ¯Ù…! Ø®ÛŒÙ„ÛŒ Ø¬Ø§Ù„Ø¨ Ø¨ÙˆØ¯ ğŸ™Œ';
        lastBotQuestion = null;
      }

      if (!response) {
        const questions = extractQuestions(text);
        for (const q of questions) {
          const found = dictionary.find(item => item.keywords.some(kw => q.includes(kw))) || findBestMatch(q);
          if (found) {
            response = found.answer;
            lastBotQuestion = /[ØŸ?]$/.test(response) ? response : null;
            break;
          }
        }
      }

      if (!response) {
        const yn = handleYesNo(text);
        if (yn) {
          response = yn;
          lastBotQuestion = null;
        }
      }

      if (!response) {
        const found = dictionary.find(item => item.keywords.some(kw => text.includes(kw))) || findBestMatch(text);
        if (found) {
          response = found.answer;
          lastBotQuestion = /[ØŸ?]$/.test(response) ? response : null;
        }
      }

      if (!response) {
        response = fallbackReplies[Math.floor(Math.random() * fallbackReplies.length)];
        lastBotQuestion = null;
      }

      addMessage(response, 'bot');
    }, 600);
  }
</script>
</body>
</html>
